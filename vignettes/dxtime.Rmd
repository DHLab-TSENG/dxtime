```{r, echo=FALSE} 
knitr::opts_chunk$set(error = TRUE) 
```

---
title: "Getting started with dxtime"
author: "Yi-An, Chu"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{dxtime}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## 安裝套件
```r
install.packages("devtools")
# Install development version from GitHub
devtools::install_github("DHLab-TSENG/dxtime")
library(dxtime)
```

```{r setup, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(collapse = T, comment = "#>")
options(tibble.print_min = 4L, tibble.print_max = 4L)
install.packages("C:/Users/anay1/Desktop/R/dxtime")
library(dxtime)
```
## 範例資料
以下功能介紹皆以`pat_dm`以及`record_dm`做為範例。  
pat_dm中共6000名個案，1000位病例組(label=1)，5000位為對照組(label=0);   
record_dm為該6000名個案在指標日(發生疾病/最後一筆...)的之診斷紀錄。  
```{r}
head(pat_dm)
head(record_dm)
```
## 功能說明
### 一、篩選符合研究長度之個案及診斷紀錄  
 
在對照病例研究，會探討回溯期間內的暴露因子與疾病發生的關係。隨著回溯時間長度越長，所囊括的暴露的危險因子會越多，樣本比較之下，將會造成「回溯時長較長的樣本，危險因子較多」的偏誤。  
為避免這種偏誤，固定追蹤時長是較佳的作法。但每個樣本的發病日期(indexday)並不相同，在filterCasesRecords()可回推追蹤時間，找出追蹤時間範圍內的診斷資料；此外，資料長度不足的樣本也可將之排除。  

需設定的參數有:  
`predictwindow`: 預測天數，意指「想要於指標日多久前進行預測」。    
`followindow`：此研究所設定的追蹤時長，將用於篩選時間範圍內的診斷紀錄。  
`followindow_limit`：將資料長度不足的個案於以排除，預設為0。  
`count_limit`：若是紀錄筆數過少，可能意味著該個案極少至此醫療單位看診，研究者可設定診斷紀錄的數量下限，來決定是否採納此個案之紀錄，預設為0。  

執行結束會產生兩種結果，分別是DataFile_pat及DataFile_rec。

```{r}
#dxData <- merge(record_dm,pat_dm[,c("ID","label")],by="ID",all.x=T)
length <- filterCasesRecords(DataFile = record_dm,
                             ID = ID,
                             ICD = ICD,
                             date = date,
                             predictwindow = 180, 
                             followindow = 6500, 
                             followindow_limit = 180, 
                             count_limit = 2 
                             )
head(length$DataFile_pat) 
head(length$DataFile_rec) 

```
以上框結果說明：

第一種結果`DataFile_pat`，followperiod計算該個案在預測日之前的資料長度，而n在全部資料中計算該個案的資料筆數，如符合研究設定的篩選條件的個案，在cri顯示TRUE，反之則為FALSE。  

第二種資料`DataFile_rec`，從符合個案的資料篩選出符合研究長度(followindow)的診斷紀錄。  


### 二、配對個案  
避免干擾因子的影響，研究者可將重要的人口學特徵，例如:性別、年齡、種族等等進行配對，使對照組的人口學特徵的分布與病例組相似。在matchCases()使用傾向配對的方法，將配對變數置入羅吉斯回歸中，得到所有干擾因子的發病機率pscore。最後以pscore相同者配對，找出匹配病例組的對照組。  
使用者須給定要匹配的變量以及label。將匹配變量以向量輸入至`matchedVariable`參數。結果會輸出被配對到個個案以及pscore。

```{r}
match <- matchCases(DataFile = pat_dm,
                    ID = ID,
                    label = label,
                    matchedVariable = c("age","SEX"))
head(match)
nrow(match)
```

### 三、切分時間窗  
由於在不同的暴露期間，其他疾病與觀察疾病的關聯會有所差異，使用cutWindow()能將暴露期間切分為數個時間窗，呈現出樣本罹患所有疾病的狀況。另外，此方法使用的是grouped code的方式，將ICD以CCS分類，最後以二元碼的方式呈現。  
在劃分時間窗時，除了群組編碼的轉換，另外一個重要的變數:年齡，也可以一併進行處理，由於年齡會隨時間變化，同一個樣本在不同時間窗的年齡會隨之推移，因此cutWindow()可在切分時間窗時一併進行窗內年齡的計算，最後可選擇以二元碼(預設以45歲為分界)或以實際數值的型態呈現。


需設定的參數有:  
`getPeriodage`:預設為FALSE，如設定為TRUE，則需要在輸入資料中先給定生日資料，最後計算出的periodage以數字型態呈現，若需要以二元形式呈現，可將binaryage=T。  
`predictwindow`: 預測天數，意指「想要於指標日多久前進行預測」。    
`window`：設定時間窗的長度。  
`N`：設定時間窗數量，注意：若該個案在某時間窗中沒有診斷資料，將會自動補0。  
`icdcount`：定義在追蹤期間，多少個疾病診斷碼(ICD)視為該患者具有該疾病(ccs)。  

```{r}
forcut <- merge(record_dm,pat_dm[,.(ID,BIRTHDAY)],all.x=T)
head(forcut)
windowcut <- cutWindow(DataFile = forcut , 
                       ID = ID ,
                       ICD = ICD , 
                       date = date ,
                       getPeriodage = T,
                       #binaryage = T ,
                       BIRTHDAY = BIRTHDAY ,
                       predictwindow = 180 ,
                       window = 360 , 
                       N = 5 ,
                       icdcount= 2)
head(windowcut[,1:10])
```
以上述結果說明：  
periodage代表該個案在該時間窗的年紀。1為大於等於45歲；0則反之。  
window_N代表時間窗的次序，數字越小越接近指標日。  
其餘的數字欄位為CCS的編碼，1表示該個案於該時間窗中得到該CCS疾病。  

### 四、選擇特徵  
以grouped codes的方式，將ICD轉換成CCS，並且進行COX單變量回歸後，選出p-value<0.05 & 得病人數>casecount_limit的特徵；  
可以用全長度資料做一次特徵篩選，也可以做多時間窗的特徵篩選。  

需設定的參數有：  
`icdcount`：定義多少個疾病診斷碼(ICD)視為該患者具有該疾病(ccs)，每個window會分開計算。  
`casecount_limit`：若罹患某疾病(CCS)的人數過少，可設定最低下限予以限制，避免被篩選為特徵。  
`predictwindow`: 預測天數，意指「想要於指標日多久前進行預測」。   
`window`：設定時間窗的長度。  
`N`：設定時間窗數量，注意，若該個案在某時間窗中沒有診斷資料，將會自動補0。  
`isDescription`：解果承憲的特徵表是否顯示CCS的中文描述。  

```{r}
head(length$DataFile_rec)
forselect <- length$DataFile_rec[length$DataFile_rec$ID %in% match$ID,]
forselect <- merge(forselect,pat_dm[,c("ID","label")],by="ID",all.x = T)
feature <- selectFeature(DataFile = forselect,
                         ID = ID,
                         ICD = ICD,
                         date = date,
                         icdcount = 2,
                         #BIRTHDAY = NULL,
                         label = label,
                         casecount_limit = 10,
                         type = "single",
                         predictwindow = 180,
                         window = 360,
                         N = 5,
                         isDescription = F
                         )

head(feature[[1]])
```
以上述結果說明：
feature涵蓋每個時間窗的篩選結果，有幾個時間窗就有幾個table。  
以第一個table舉例，HR為`100`的風險比率；Pr(>|z|)為p-value；case count為該時間窗中共有多少個案患病，最後，若p-value<0.05 & 得病人數>casecount_limit會在selected顯示為TRUE。

### 五、以COX回歸建立預測模型
使用grouped codes的方式，用CCS為預測變量進行建模。
需提供三種資料表來進行建模。分別是  
1. **DataFile_cutdata**：劃分為時間窗的資料，使用cutWindow function可以獲得；  
2. **DataFile_feature**：要放入作為預測變量的特徵；  
3. **DataFile_personal**：個案資料，包含ID、label、SEX、indexage，若有需放入一併建模的特徵，也須於此表格提供；  
另外，需設定的參數有：  
`predictor`：除了CCS之外，若是有個案相關資料須一併做為預測變量進行建模，需於此填入變量名稱。並於DataFile_personal提供該變量資料。  
`method`：分為"per window"以及"one window"兩種方法，兩種方法的差別在於DataFile_feature的不同，若是多時間窗的特徵篩選，此參數應設為"per window"，若是沒區分時間窗的特徵則設為"one window"。  

```{r}
#DataFile_cutdata <- windowcut
#DataFile_feature <- feature
record_dm <- record_dm
lengthdata <- unique(record_dm[,futime:=max(date)-min(date),by="ID"][,.(ID,futime)])
personal <- merge(pat_dm[,.(ID,label,SEX,age),],lengthdata,by="ID",all.x=T)
head(windowcut[,1:10])
head(feature)
head(personal)

```

```{r}
coxmodel <- analyWindow_COX(DataFile_cutdata = windowcut,
                         window_N = window_N,
                         ID = ID,
                         DataFile_feature = feature,
                         DataFile_personal = personal,
                         label = label,
                         futime = futime,
                         predictor = c("SEX","age"),
                         #periodage = periodage,
                         isDescription = F,
                         method = "per window",
                         N = 5)
coxmodel[[1]]

```


### 六、以LSTM建立預測模型
LSTM為RNN中最常使用的模型，運用於做時間序列分析有良好的效果，在運算過程中能自動擷取具影響力的危險因子進行建模。使用analyWindow_LSTM()，使用者可以不需了解tensorflow中複雜且與此研究類型不相關的參數，研究者可直接根據analyWindow_LSTM()所需的參數進行設定，便可迅速得到以LSTM建立的疾病診斷時序預測模型。
此方法可用於多個時間窗建立預測模型，也可用於單個時間窗建立預測模型。  
需提供二種資料表來進行建模。分別是  
1. **DataFile_cutdata**：劃分為時間窗的資料，使用cutWindow()可以建構；  
2. **DataFile_personal**：個案資料，包含ID、label、SEX、indexage，若有需放入一併建模的特徵，也須於此表格提供；  
另外，需設定的參數有：  
`predictor`：除了CCS之外，若是有個案相關資料須一併做為預測變量進行建模，需於此填入變量名稱。並於DataFile_personal提供該變量資料。  
`N`: 時間窗數量
`batch_size`：batch size將決定一次訓練的樣本數目。預設為100。
`Epoch`：當一個完整的資料集通過了神經網路一次並且返回了一次，這個過程稱為一次epoch。預設為10，但會經過Validation的驗證後找到最佳的迭代次數，
`units`：設定隱藏層的神經元數量。預設為16，常見的還有32、64等。


```{r}
library(keras)
#use_session_with_seed(10) #use_session_with_seed will be deprecated in the future. use set_random_seed instead.
library(tensorflow)
set_random_seed(10)
install_tensorflow()
# check version
packageVersion("keras")
packageVersion("tensorflow")
lstm <- analyWindow_LSTM(DataFile_cutdata=windowcut,
                         window_N,
                         ID,
                         periodage=NULL,
                         DataFile_personal=personal,
                         label,
                         predictor=c("SEX"),
                         N=5)
## evaluate
model <- lstm[[1]]
x_test <- lstm[[2]]
y_test <- lstm[[3]]
model %>% evaluate(x_test, y_test, batch_size = 100)
model %>% predict(x_test, y_test, batch_size = 100)
```
